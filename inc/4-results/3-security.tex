\section{Security}
\label{sec:security}

Most applications on a blockchain platform will more or less inherit the blockchain's own security model. There is always a risk of censorship, loss of connectivity, block reorganization, and more, but open blockchains could still be the most secure computing platform we have for MPC without a TTP. A lottery is special in that the rewards can be incredibly high, and for that reason it risks attracting more motivated attackers than applications that do not handle large amounts of value in a single transaction. By viewing security as a game of economics, the rewards for successful attack a large lottery can be so high that extraordinary measures can be taken by adversaries to succeed. We must therefore review the commonly used models for considerations such as censorship resistance, network attacks, and block reorganizations when discussing the security of a lottery. 

\subsection{Loss of connectivity}
The lottery is inherently interactive in that participants need to make commitments and reveal secrets during the lottery playing phase. Since players who don't make a commitment or reveal within the time limits lose by default, loss of connectivity is an issue. Since the lottery protocol requires interactivity, there is little we can do to mitigate this other than using longer time intervals between phases in the match contracts, so that players have a chance to reconnect before time limits expire. 

While players could insure against losing connectivity by outsourcing the interaction with the lottery to some third party service, that would entail sharing of secrets with a third party, which is a security consideration of its own. Players could run the lottery from servers under their control in data centers at different geographical locations than their web browser, and thus be quite safe against losing connectivity with minimal risk of leaking the secrets, but this is complicated for many users. 

\subsection{Blockchain reorganizations}

A blockchain is commonly considered to be immutable once a block is included, and so the state of a dApp on Ethereum is immutable. A fork is when there exist multiple valid blocks of equal heights in the blockchain. These blocks can be equally valid, but may contain different transactions and thus represent different states of the EVM. Accidental forks can happen when blocks are mined at approximately the same time and propagated across the network so that a large proportion of nodes have a block the rest of the network does not have. Accidental forks can also happen during software releases that may contain bugs or conflicting consensus protocols. While such network splits are usually resolved quite quickly and the entire network reach consensus on one of the forks, there is a risk for a chain reorganization where a state is not immutable until a few blocks have been mined on top of it.

A fork can also be part of an attack by an adversarial miner who aims to replace a larger section of the most recent blocks in order to alter the state. Such an attack is done by secretly mining an alternative chain while waiting for a certain state to be reached on the main blockchain, and then broadcasting the secret chain in hope that the network will accept the adversary's alternative chain more favorable to the adversary. This allows the adversary to trick the network into believing the blockchain is in a certain state, while it will actually change once they broadcast the secret chain.

This is a concern for a lottery in that the results of a lottery can be reversed if the adversary is not happy with the result. Reversing the entire lottery, however, is probably not possible as block reorganization attacks are very expensive and difficult to perform on long chains. A cheaper attack would be to wait for one's opponents to reveal their secret, and then reorganize the blockchain if the result is not favorable to the adversary. While it's certainly difficult to do so, we don't know what the expected pay-off would be for such an attack if the lottery prize is extremely high.

This concern can also be mitigated by using longer time intervals between phases, as block reorganization attacks get more expensive the more blocks are involved. The production of blocks is quite inherent to the blockchain platform itself, and there is not much an application on the blockchain can do about that. One way of decreasing the risk of it happening is using a blockchain that has a high mining power and much decentralization among miners.

\subsection{Censorship and transaction blocking}

\subsubsection{Network attacks} While blocking of the network and eclipse attacks are relevant for all network applications, it is commonly assumed that long lasting attacks of this type will not happen. While there's always a risk of it happening, we can choose security parameters that minimizes the consequences of such attacks. Again, with an interactive lottery, we can't do much more than to increase the time intervals between phases, so that the chance of getting one message through during that interval is high even when under attack. For targeted attacks on the network, players can also hide their location by accessing the network with privacy enhancing tools. 

\subsubsection{DoS attacks}
A denial-of-service attack is done by flooding a network with bogus messages so that it is incapable of responding to other messages. This can be done on a blockchain by broadcasting a large number of transactions with high transaction fees, so that miners will only include the bogus transactions in the blocks and ignore other transactions with normal transaction fees. Such an attack is costly to withhold over time, as transaction fees must be paid. But if the expected value of successfully blocking an opponent in a match in a lottery is high, it can easily be worth it. Such a transaction flooding attack can easily be countered by broadcasting a transaction with even higher transaction fees, so the relationship between attacker and defender is asymmetric, as the defender only needs \emph{one} transaction to go through, while the attacker must block \emph{all} other transactions. A lottery client should take this into account and be ready to make transactions with high transaction fees if it suspects a DoS attack is under way.

\subsubsection{Censorship}
For a blockchain to have a high degree of liveness, we must assume that miners will include transactions by no other discrimination than the size of the transaction fees. However, miners are free to select which transactions they include in the blocks they produce. They could for any reason refuse to include a transaction from or to a certain address, including from certain participants in a lottery. The main concern is an adversary paying miners bribes on the condition that transactions from certain participants are not included, or that miners themselves play in the lottery with the intent of abusing their power to censor. We see from how the tournament tree looks like that one would only need to block transactions from $log_2(N)$ participants to make sure that one wins each match by the other player failing to make a commit or reveal transaction. 

While it's likely that a non corrupted miner will include transactions censored by other miners, and that the likelihood of that happening increases with time, corrupted miners can also choose to ignore blocks that are produced by honest miners. Such a situation could have the corrupted miner cause a block reorganization where blocks including censored transactions are replaced by the corrupt miner's blocks. So it is actually a combination of censorship and block reorganization which might be quite powerful if the corrupt miner controls a large share of the mining power.

The censorship concern can be mitigated in several ways. One is again to increase the interval between phases. Another is to make the lottery less interactive and somehow reduce the amount of transactions that are necessary for completion. Another is to use anonymous transactions in which miners cannot know what the result of the transaction will be at mining time.

\subsection{Compromised client and phishing}

\subsubsection{Compromised secrets}
If secrets are generated on the client such as a web browser, an adversary could trick participants to using a compromised client that leaks secrets to them. While this consideration is quite broad, as an attack would go through a player's computer and there is little we can do about a compromised computer when designing the lottery. Following standard practices for designing secure applications can be done in the application layer of the dApp.

\subsubsection{Compromised client}
Since it's up to players to verify that the lottery is set up correctly by validating all the match contracts in the tournament tree, a compromised client could falsely validate a tournament that is set up in an adversary's favor. We assume that each player is capable of verifying that the lottery and tournament is set up correctly. An adversary could make it look like the lottery is set up correctly by luring players into a fake site with phishing. Verifying that the lottery is set up correctly is done by the client, as the smart contracts cannot do this on their own in our current design. E.g. the final match contract is set in the master contract after initialization. The master contract does no more validation than verifying that the final match contract is a contract of that type. An adversary lottery organizer could make a bogus final match contract in which they are guaranteed to win, and need not be related to the actual tournament at all. Nonetheless, players make deposits to the master contract, and the master contract will pay the prize to whoever is the winner of the match contract it was set up to use.

Perhaps having some sort of community in a chat room or a bulletin board for each lottery could mitigate this. Honest players could build up a reputation of trust and help other players, and suspicious lotteries could be reported and inspected by experts. Displaying a warning banner notifying players about the dangers of such attacks could also be a permanent fixture in the client application.
