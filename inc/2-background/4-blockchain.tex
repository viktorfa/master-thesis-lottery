\section{Blockchain}
\label{sec:blockchain}

A blockchain is an append-only data structure of cryptographically linked blocks. A blockchain has a first block of height $0$ which is often called the \emph{genesis block}. Each subsequent block of height $h$ contains a cryptographic reference to the block of height $h-1$. New blocks are appended regularly, and the most recent block is called the \emph{tip}. Blocks can contain a set of transactions, each of which represents a transition of a global state. The global state is implicitly defined by all the ordered transactions in the entire blockchain. Due to the links from a block to the previous block, one block cannot be altered without altering all subsequent blocks as well. If a blockchain is widely distributed and blocks are hard to produce, it becomes increasingly more difficult to alter a block the older it is. This gives blockchains an immutability property that makes it fit for purposes such as transferring and storing value.

A blockchain is commonly used as a global ledger that represents a state that defines ownership of various digital assets, these assets being primarily cryptocurrencies, but also property deeds and financial instruments~\cite{tschorsch_bitcoin_2016}. Blockchain systems are also typically public and open for anyone regardless of their legal status or geographical location. A blockchain can be used for high value transfers and critical computations because it is considered to have the properties of finality and liveness~\cite{garay_bitcoin_2015}. 
The term blockchain usually does not mean just the data structure, but also the implicit state represented in its transactions, the network of stakeholders interacting with it, and applications built on top of it. We will here consider the \emph{blockchain network} to be the interconnected nodes running the full client software of the blockchain.

\begin{figure}[htbp]
  \centering
  \includesvg[width=\columnwidth]{figures/blockchain.svg}
  \caption{A chain of blocks linked with hashes.}
  \label{fig:blockchain}
\end{figure}

\subsection{Transactions}

The purpose of a blockchain is to enable participants to reach a global consensus on an ordered list of transactions. Transactions are validated and embedded in blocks, and all transactions implicitly represent a state. In Bitcoin \cite{bitcoinwhitepaper}, the state that is represented is who has the authority to spend which coins. The state can be abstracted to represent a set of accounts with balances denominated in bitcoin. A transaction can specify a short script that makes some coins spendable by executing a specific script with certain arguments – usually involving a digital signature. Transactions can be abstracted to represent transfers of coins between accounts.

Each transaction is applied to a state and results in an altered state. Transactions are validated before they are applied to the state. The process of validating transactions consists of multiple steps. First, the transactions must be of a valid format. Only a limited set of instructions can be used, and the total size of the script is limited to a maximum length. Second, the transaction's script must be executed correctly. Third, the transaction cannot spend more coins than it has authority to spend.

All coins in Bitcoin begin their life as a transaction output. Each block contains a \emph{coinbase transaction} which contains some coins, and the miner of that block decides how those coins can be spent. We assume the miner makes it so that the coinbase transaction coins can be spent by providing a signature with the miner's private key. The miner realizes this by defining the coinbase transaction's \emph{output script} – a machine readable spending policy for those coins, which will be stored in the block. 

The output script is a list of operations that will be executed on the Bitcoin virtual machine (BVM). This virtual machine is stack based with a limited instruction set. While the coinbase transaction only has an output script, all other transactions, which we will call ordinary transactions, have an input script and and output script. The input script, as well as a reference to a previous transaction, must be defined in each ordinary transaction. When an ordinary transaction is validated, the output script of the previous transaction it references will be pushed to the stack of the BVM. Then the input script of the transaction will be pushed to the stack of the BVM, before the program is executed. If the stack at the end of the execution only contains a \texttt{true} value, the second step of the validation has succeeded. 

In addition to the input script and a reference to a previous transaction, an ordinary transaction also contains a new output script and the amount of coins it spends. A valid transaction will move the coins it spends to a new output script. And so each transaction moves coins from one output script to another, and a coin's entire history will be stored in the blockchain. 

\begin{figure}[htbp]
  \centering
  \includesvg[width=0.5\columnwidth]{figures/transactions.svg}
  \caption{Transactions in Bitcoin.}
  \label{fig:bitcoin-transactions}
\end{figure}

\subsection{Mining}

Blocks are produced by miners who validate transactions and calculate a cryptographic puzzle that requires large amounts of computing power to be expanded. The puzzles work as a probabilistic process where miners need to map a block's data to a small subspace of a function's range. Such a mapping constitutes a valid proof-of-work (PoW) and only blocks with a valid PoW will be accepted by other nodes. 

PoW is done to make producing blocks hard. Blocks being hard to produce has three features: First, the network will not be flooded with new blocks. Sybil attacks are common in unpermissioned networks, and it's hard to distinguish real users from sybil impersonators. Since PoW is easy to verify but hard to prove, performing a sybil attack is expensive. Second, it makes it possible to reach consensus. A blockchain can only have a single block of a specific height, so if there are multiple blocks of the same height, or even chains of blocks with the same height, the network can simply choose to accept the blocks with the most PoW. Miners are rewarded for each block they produce, but only if it's accepted by the network. This ensures that miners will only be rewarded if they mine on the chain everybody consider to be the correct one. Third, it makes it difficult to rewrite blockchain history. Since each block is costly to produce, replacing an accepted block with another will be costly. This makes sure that the cost for an adversary to rewrite history is high, which again makes the network trust the blockchain's finality.

{\bf Natural block reorganization.}
Since many miners are competing simultaneously, we will from time to time encounter a situation when two or more valid blocks are produced at about the same time. A miner who produces a valid block will broadcast it to other miners, who will in turn propagate it through the network. When miners receive a valid block of height $h$ from a peer, they will start mining on top of that block to produce the block of height $h+1$. If several blocks are propagated through the network at about the same time, some miners will have different blocks of equal height, and will need to make a decision on which block to continue mining on top of. This situation is called a natural fork, as the chain is split at the end into more subchains. Eventually one of the subchains will be appended more than the other, and miners will accept whichever subchain that is longest \footnote{In Bitcoin, the subchain with the most PoW will be chosen, but unless the split is very large, this will always be the longest subchain.}. The shorter subchains will be abandoned and their transactions will not affect the state represented by the blockchain.

Small block reorganizations happen regularly as miners can mine a block of the same height before either block has propagated through the entire network. This does not necessarily mean that any transactions are reversed, as the two blocks are likely to include quite similar transaction sets. Larger accidental block reorganizations can also happen during software releases that may contain bugs or conflicting consensus protocols \cite{andresen_march_2013}, but this does not happen often on well-established blockchains.

\begin{figure}[htbp]
  \centering
  \includesvg[width=\columnwidth]{figures/blockchain_fork.svg}
  \caption{A natural blockchain fork.}
  \label{fig:blockchain-fork}
\end{figure}


\subsection{Blockchain threats}

Since Bitcoin's inception there has been discussions on the security and threat models to blockchains. Much of the discussion involves the role of miners and their ability or inability to control the network. While there has been few unsuccessful attacks on the larger blockchains such as Bitcoin and Ethereum, the threat models and assumptions need to be continuously reconsidered for new use cases of the blockchain.

\subsubsection{Block reorganization}
During the situation of several subchains being on the network, one view of the blockchain might give a different state than another view. Say one observer had a view with subchain $s_1$ that included transaction $t_1$, and another observer had a view with subchain $s_2$ that did not include transaction $t_1$. If $s_1$ is eventually abandoned, as miners continued to mine on top of $s_2$, then $t_1$, which seemed to be included, is no longer part of the blockchain. This phenomenon is called a block reorganization, and can potentially reverse transactions.

A block reorganization violates the immutability property of the blockchain as blocks can be removed. Since miners have an interest in mining on the same chain, as only one chain's coins will be valuable, the network tends to reach consensus on which chain is correct quite quickly. A common heuristic for the Bitcoin blockchain is to consider transactions in blocks that have at least 6 blocks appended to them as immutable, which takes on average one hour to happen. As a general rule, the more blocks are mined on top of a block, the stronger its immutability. 

A block reorganization attack can be conducted by an adversarial miner or collusion of miners who aim to replace a larger section of the most recent blocks in order to alter the state. If blocks are replaced, transactions can also be reversed. A block reorganization attack can be used to perform a \emph{double spend}, where a purchaser makes a payment that is reversed after they receive the goods for the payment. Such an attack is done by secretly mining an alternative subchain while waiting for a certain state to be reached on the main blockchain, and then broadcasting the secret subchain in hope that the network will accept the adversary's alternative subchain that is more favorable to the adversary, i.e. the payment transaction is reversed. This allows the adversary to trick the network into believing the blockchain is in a certain state, while it will actually change once they broadcast the secret subchain. For the secret subchain to be accepted by the network, it needs to be longer than the public chain. Since it's difficult to produce blocks, this can only be done successfully on average if the adversary controls more than 50\% of the mining power. As a consequence, block reorganization attacks is often interchangeably used with the term \emph{51\% attack}.

\subsubsection{Censorship}
Users can change the state of a blockchain by broadcasting transactions that will be included in a block by a miner. Due to limited space in blocks on blockchains like Bitcoin and limited computational resources on blockchains like Ethereum, there is a finite amount of transactions that will be included on the blockchain. Transactions can optionally include a fee that is paid to the miner who includes the transaction in their block, and the size of this fee is the basis on which transactions miners choose to include. If miners are merely profit maximizing, such a pricing mechanism for blockchain resources maintains the liveness and openness properties of the blockchain, as there is a single objective criterion for participating.

Miners do, however, have the power to discriminate transactions on any other basis than fees as well, e.g. on a political or self-interest basis. If a miner refuses to include transaction from a specific user, then that user will only have their transaction included if another miner includes it. If a collusion of miners all agree to not accept transactions from a specific user, and the collusion controls a large amount of the mining power, they will be able to effectively censor that user. Even if a non-colluding miner eventually mines includes the censored transaction in a block, the collusion can choose to ignore that block. Such a situation will violate the openness property, as the blockchain is no longer accessible by anyone. 

Unlike a block reorganization attack, which affects the finality of many transactions, a censorship attack can be targeted at a single user. One of the security assumptions commonly made in blockchain systems is that it is not in miners' interest to launch attacks that threaten the main security properties of the system, as miners are typically heavily invested in the cryptocurrency through e.g. capital investments~\cite{buterin_problem_2015,wuille_security_2019}. An attack that affects many users might trigger a backlash by other stakeholders and thus hurt the miners launching an attack. Since a censorship attack can target single users, it might have a lower disruption cost, i.e. cost to launch the attack, than the disruption cost of a generic 51\% attack. 

\subsubsection{Selfish mining}
Selfish mining is a type of miner behaviour that might allow censorship by a collusion with as little as 25\% of the mining power \cite{eyal_majority_2018}. While an altruistic miner will mine on top of whichever block they know about with the largest height, a selfish miner will bias their mining towards their own blocks. A selfish miner trying to mine a block of height $h$ will not immediately start to mine on the block of height $h+1$ when receiving a valid block of height $h$. Instead, they will continue trying to mine $b_h$ until they receive a block of height $h+k$ for some $k$, by when they start the same procedure again.

If the selfish miner controls a small ratio of the mining power, such a strategy will lose potential profits, as they will waste resources on subchains that will be abandoned. As the ratio of their mining power goes up, their reluctance to accept blocks from other miners will cause the network to also abandon blocks from other miners at a more frequent rate than what their respective mining power would say. This will in turn incentivize other miners to more readily accept the selfish miner's blocks, as this will decrease the chances of their blocks being abandoned and the block reward being lost.

If such a scenario plays out like that, the selfish miner can also choose to censor a certain type of transaction and force the network to join in on the censorship policy. The selfish miner enforces this by refusing to accept any block that contains a transaction of the type they censor. If the subchain the selfish miner favors is more likely to eventually be accepted, then other miners will produce blocks they are sure will be accepted by the selfish miner.
