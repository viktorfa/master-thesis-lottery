\section{Code}
\label{sec:code}

The only smart contracts used in the lottery are the master contract and match contracts which are implemented as Solidity programs. Solidity is a high level language that compiles to EVM bytecode which again can be deployed as smart contracts on the Ethereum blockchain.

Since setting up the lottery requires a master contract, many individual match contracts that are aware of each other, all in a multi-step process, this is done with a script that constructs the required contracts with correct parameters. We also have code that do unit tests and integration tests on the contracts and setup code.

Lastly, we have clients that makes it easy for lottery players and a lottery organizer to interact with the lottery application. The combination of smart contracts and these clients form a so called Dapp which is accessed in a web browser.

\subsection{Master contract}
\texttt{LotteryMaster} is the smart responsible for registering participants, taking deposits, and distributing the prize. It serves as a central hub in the lottery that all players must interact with. Whoever deploys this contract is the lottery organizer, and is the only account which can initialize the lottery by setting the final match. 

The constructor of this contract takes the number of participants, the price of participation, a start time and and end time. It is only possible to make a deposit after the final match of the lottery is set. The \texttt{finalMatch} field is a reference to a match contract which is the apex of the tournament tree of matches. This field cannot be set on deployment, as the matches in the tournament need a reference to a master contract, and the master contract needs a reference to a match contract. Due to this circular dependency, either all the matches of the first level or the single master contract need a two-step initialization. Since the gas usage of a single transaction is less than that of many, we choose to have the two-step initialization in the single master contract.

By the time set in \texttt{tFinal}, the tournament is supposed to be played. If after that time, there is no winner of the final match, then players will be able to withdraw their deposit, as the lottery was unable to complete. If the final match does return an address, then the owner of that address will be able to withdraw the entire balance of the master contract.

\subsection{Match contract}
A match contract implements a digital coin toss between two players. The digital coin toss determines a winner either by the value of the least significant bit of the result of an XOR operation on the two players' secrets, or by one of the players failing to perform the procedures in the contract by some predetermined time limit.
Due to slightly different behaviour between matches of the first level of the tournament and matches in internal nodes of the tournament, we split the code between two smart contracts who both inherit from an abstract smart contract.

A match has two players referenced by the address in the \texttt{alice} and \texttt{bob} fields. By a start time \texttt{tCommit}, the players can set a commitment of bits with the \texttt{commit()} method. Another time limit is set in \texttt{tReveal} when making commitments is no longer possible, but revealing the secret committed to is possible. This is done with the \texttt{reveal()} method which verifies that the secret is the preimage of the commitment, and stores the secret in storage. The final time limit is \texttt{tPlay}, after which players can no longer reveal secrets. By the final limit the outcome of the match is guaranteed to be determined. 

The \texttt{getWinner()} method performs the digital coin toss if both players have reveal their secrets. If either player has performed more steps than the other player, e.g. made a commitment while the other has not, the player who has done the most steps will win. If neither player has revealed their secrets, and no player has performed more steps than the other, then the winner of the match will be returned as the null address.

A match has a way to determine which players are eligible to play it. This is handled differently in \texttt{FirstLevelMatch} and \texttt{InternalMatch}. The former is initialized with an index and a reference to a \texttt{LotteryMaster} contract. Each player in the master contract is indexed so that each player is paired with another which is their opponent in the match of the first level. The latter is initialized with a reference to two matches, \texttt{left} and \texttt{right}, of the previous level in the tournament. These matches will return their winner in the \texttt{getWinner()} method, which is used to determine the players of the match in the next level. If a previous match returns the null address as the winner as either left or right, then the match will be won by the only player if they just perform the commit step.

\subsection{Lottery setup code}
The lottery setup code is written in Javascript, an interpreted language that runs in all modern web browsers and on the NodeJS runtime environment. Since it's common to make web clients for smart contract applications and modern web apps are usually programmed in Javascript, that language is commonly used in the layer between user and the blockchain API. The Truffle framework is a library that provides a useful abstraction to smart contracts and the Ethereum RPC client, and includes tools for handling the development lifecycle of smart contracts. Web3js is a comprehensive library to interact with Ethereum and the EVM in Javascript.

In order to set up a valid lottery, the master contract and match contracts need to be initialized with correct parameters. In addition to testing and simulation, this is the main purpose of the lottery setup code. The lottery is setup by first deploying a master contract, then deploying, level for level starting from the first level, match contracts that constitute a valid tournament tree, then initializing the master contract with the final match of the lottery tree. The setup code finds the correct parameters for time limits, indices of first level matches, and left and right addresses for internal matches. 

The simulation code consists of two test suites. The first does the routine a lottery organizer needs to do in order to set up a lottery, which is creating and deploying the master contract and all match contracts. The second does all of what the first does in addition to simulating the lottery being played. In the second suite, players join by making deposits and then play each level of the tournament until one player is left as winner and withdraws the prize.
The time elapsed and gas used is recorded for each simulation for analysis.

These listings have been truncated somewhat and are not necessarily compilable code. See the Github repository and appendix for full working code.

\lstinputlisting[language={Solidity}, caption={Lottery master contract}, label={lst:LotteryMaster.sol}]{listings/LotteryMaster.sol}
\lstinputlisting[language={Solidity}, caption={Common code for lottery match}, label={lst:CommonMatchCode.sol}]{listings/CommonMatchCode.sol}
\lstinputlisting[language={Solidity}, caption={Lottery first level match contract}, label={lst:FirstLevelMatch.sol}]{listings/FirstLevelMatch.sol}
\lstinputlisting[language={Solidity}, caption={Lottery internal match contract}, label={lst:InternalMatch.sol}]{listings/InternalMatch.sol}