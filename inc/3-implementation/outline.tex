\section{Tournament lottery outline}
\label{sec:outline}
\subsection{Digital coin toss}
A coin toss is a random process in which a binary outcome is decided. While a physical coin toss is decided by a coin landing on either the heads or tails side, a digital coin toss is determined by a function with domain ${0, 1}$. A coin toss is usually thought of as the outcomes being equally likely, but either outcome can be biased to almost arbitrary granularity.

We consider the case where two untrusting parties want to arrive at an unpredictable outcome that is verifiable. One way of achieving this is using a two round protocol where each party commit to a hash in the first round, and then reveal the preimage in the second round. If we assume that a secure hash function is used, then either party can see the commitment of the other player without being able to guess what the preimage is. When the preimage, or secret, is revealed in the second round, either party can verify that the secret is actually the preimage of the commitment, thus making the protocol verifiable. The coin toss is performed by doing an operation, such as XOR, with both the parties' secrets as operands. The result of this operation is completely unpredictable to either party, as they do not know the other party's secret. For a 50-50 coin toss, we can simply decide the outcome by something simple as whether the least significant bit of the result is 1 or 0. For a biased coin toss, we could instead do a less than operation, so that the toss can be biased to a level limited only by the length of the secret bitstring.

A secure implementation of this protocol would require the parties to mix in some salt when hashing the secret, i.e. by concatenating the secret with a predefined string. This is to prevent one party from committing to the same value as the counterparty, so that the preimages are equal to each other. That would result in the outcome being predictable, i.e. always 0 if we use the XOR operation. 

Say we have Alice and Bob conducting a digital coin toss with commitments $C_A$ and $C_B$ and secrets $S_A$ and $S_B$. The salt is a predetermined string both parties use $salt$, and the hash function is $H()$. The commitments are calculated as $C=H(salt, S)$, and are verified by the same operation. We get the result of the XOR operation $r=S_A \oplus S_B$. The outcome is then determined by if $r\ mod\ 2 = 0$, then Alice wins, or if $r\ mod\ 2 = 1$, then Bob wins.

\subsection{Tournament of coin tosses}
To determine a winner out of more than two participants, we can construct a tournament tree of 2 player coin tosses where players can advance to higher levels until they eliminate their last opponent. We assume the tournament tree is a full binary tree where each node represents a match. With $2^N$ players, there will be $\frac{N}{2}$ matches as leaf nodes and $\frac{N}{2}-1$ matches in total. Each internal node of the tree will have a match as left child and a right child. The players in each node is determined by the winner of their child match nodes. We can imagine the leaf nodes having players as left and right children, who are the players in the leaf node matches. The tournament will proceed in sequential rounds starting from the lowest level of the leaf nodes. Once all the matches of level $l$ is determined, the tournament proceeds to level $l+1$. The winner of the single match in level $L=log_2(\frac{N}{2})$ is the winner of the tournament. To avoid the tournament halting if a player does not perform the coin toss protocol in a match, we can assume a player loses by default after a timeout for each level predefined as $t_l$. If none of the players in a match perform the digital coin toss, we can define the match as having no winner, so that the next match will be automatically won by the other player. If the final match is undetermined by $t_L$, we consider the entire tournament as undetermined.

\subsection{Why the tournament is not deterministic}  % Because of time outs
It's worth taking a moment to consider the implications of the timeout conditions in the tournament. Ideally, both players in each match will perform the digital coin toss. Since the secret in the coin toss is committed to, there is just one possible result of that match if the coin toss is completed successfully. However, if either party does not reveal the secret in the coin toss, then either player can win, regardless of what the result of the coin toss would be. This means that even if all players commit to secrets for each level of the tournament prior to playing a single match, any player can actually be the winner depending on who times out where. Note that if we assume that all players will perform the coin toss successfully, then the tournament is completely deterministic once all commitments have been made, and there is just one single valid winner for that particular ordered set of players and commitments. If that were the case, we could even use a single commitment and secret from each player that is used for each level of the tournament.

\subsection{How to exploit a non-deterministic tournament}  % Why we need different commitments for each level
In a practical implementation of the tournament, we would have to have timeouts to avoid the protocol halting. We must also assume that players can be colluding. In a collusion, each player would know each others secret, so they would know who would win against whom. If we simply used the same secret for matches in all levels, then even if the result is unpredictable before all players have revealed, a collusion could wait for all the non-colluding players to reveal, then tactically choose which players of the collusion should reveal, so that they are guaranteed to win matches in subsequent levels. Because of this, unless we can assume no collusion, we must require players to commit to different secrets in each match, and so make the protocol interactive.

\subsection{Set up phase}
For a digital lottery to use such a tournament, it would need to set up the lottery with a tournament as a system with many components. We will naturally see it in the context of a blockchain platform with smart contracts. Our implementation of a lottery consists of a set of match contracts and a single master contract that serves as a hub. Each match contract needs to know who the eligible players of the match are. For internal nodes, this is done by initializing them with a \texttt{left} and \texttt{right} field which point to contracts in the level below. The leaf nodes will be initialized with an index and a reference to the master contract. The index is an index in a list of all players that is maintained by the master contract.

The master contract, in addition to maintaining the list of players, is used to take deposits which is payment for joining the lottery and validating withdrawals. Since one must know the winner of the final match to know who is eligible to withdraw the prize, the master contract must be initialized with a reference to the final match contract. Since all internal node need a reference to a node below them which ultimately means a reference to a leaf node, and the leaf nodes need a reference to the master contract, we cannot initialize the master contract and match contracts in just one step each. We need to first create the master contract without a reference to the final match, then initialize all the match contracts with leaf nodes referencing the master contract. Then the lottery will be fully initialized once we have the address of the final match contract and we pass it to the master contract as a one-time setter.

\subsection{Deposit phase}
Once the master contract and all the match contracts are set up correctly, any prospect player can verify that the contracts are set up correctly by inspecting each contract. Players can then join the lottery by sending a deposit transaction with the ticket price as value to the master contract. Making a deposit will increase the master contract's balance and insert the sender in a list of players. A leaf node match will have been initialized with an index that points to that player as one of the players in the match. Deposits will be possible as long as the lottery is not full and a start time is not yet reached. The lottery is full once the amount of deposits has reached the predefined number of participants. If the lottery is not full by the start time, the lottery will not be able to start. If the lottery is full by the start time, the lottery moves into the next phase.

\subsection{Playing phase}
Each leaf node match contract should have a time $t_{commit}$ which is equal to the start time of the lottery by when players can make commitments to the digital coin toss. $t_{reveal}$ is some time later when players can make a reveal transaction with their secret which is validated in the smart contract. The last time field of a match contract is $t_play$ by when it's no longer possible to reveal and the match is decided. If both secrets are revealed, the contract will calculate the winner by checking the least significant bit of the result of an XOR operation on its players' secrets. It being 0 results in the left player winning, it being 1 results in the right player winning. If either one party has not revealed their secret, the other player will win without performing the coin toss. If neither player has revealed, the coin toss is not performed, and the winner of the match is undetermined. Whoever plays a match against an undetermined player will win by default.

Internal match nodes should have a $t_{commit}$ which starts when matches in the level below have their $t_{play}$ limit. As mentioned, each internal match node has a reference to matches from the previous levels from where the winning player is eligible to play the current match. This way the tournament proceeds level by level with time limits defined at contract initialization. Players will need to make transactions to the match contracts which validate the sender and the inputs. The final match will be played just like any other match, but the master contract will have a reference to this match, so that it can validate the winner.

\subsection{Withdrawal phase}
Players can send a transaction to the withdraw function of the master contract. If the final match has a winner, it will transfer the balance of the master contract to the sender after validating that the sender is the same account as the winner. If a time limit $t_{final}$ is reached, and the winner of the final match is not determined, players can withdraw their initial deposit, as the lottery is considered undetermined.