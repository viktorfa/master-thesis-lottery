\section{Possible changes to the implementation}
\label{sec:optimizations}

During the implementation we discovered some interesting possibilities for optimization and slightly different designs to the lottery. One of these, the two types of match contracts, was implemented and tested, but we chose to limit our experimentation to keep the project manageable. This section will introduce some tweaks that might make the lottery more secure and more scalable.

\todo{This section is for the most part notes to myself at this point. When I was programming I had some ideas of how to improve things, but I'm not sure if it makes sense discussing it in the thesis.}

\subsection{Off-chain negotiation of coin tosses}
There is a possibility to resolving the digital coin tosses off-chain. When both parties in the digital coin toss have made their commitments to the blockchain, the result is determined, as there is only one secret that can be validated for that commitment. Instead of both parties actually revealing their secret on-chain, the parties can show each other their secrets through some other communication channel or a bulletin board. The parties will then be able to see who will win the digital coin toss if they both proceed to reveal it on the blockchain. Because of the timeout condition, the losing party can save some transaction costs by "giving up" and avoid making the reveal transaction. The other party, who would have won the digital coin toss if both had revealed their secret, makes their reveal transaction and will then win because the other party has timed out.

We can even further optimize this by requiring participants to make all their commitments in the deposit transaction. Players in a match can then reveal their secrets before any commitment is made in the match contract, and the losing player can simply not even make a commitment and so give up without spending any gas. We could modify the match contract so that if only one player has made a commitment by time $t_{reveal}$, that player will win. We could additionally accept a forfeit transaction in which one player signs their commitment with their private key and by that gives up.

\subsection{Using (hierarchical) deterministic secrets (HDS)}
Could we use HDS to commit to a series of secrets in the deposit transaction without revealing them all at each level? Maybe, but it would only be verifiable at the end, and we would risk someone lying about their secrets and not being verified at the end. With some higher deposits and/or punishment, maybe it could work.

A simple version of this is using deterministic secrets. It would work as following. Each player commits to a commitment which is the hash of a secret and a public identifier such as their address. Each player generates a series of secrets, one for each level of the tournament tree, from the initial secret they committed to. The i-th key of the series is generated as hash(secret, i). During the tournament, each player must present what they claim is the i-th secret key to their opponent, and the coin flip will be determined according to the players' i-th secret. Note that there is no way to verify that their i-th secret is actually what they claim during the playing phase, as the initial secret cannot be revealed. After a winner has been determined, we enter the verification phase, where the winner must reveal their initial secret, and the smart contract verifies that the tournament was played with the correct secrets at each level. 
The problem with this is what do to if the verification fails. People will have wasted gas in a lottery that failed. We could kick out that player and start over, but it's kinda complicated to do that. We must also have a way for the master contract to ask each match contract about which key was used. Maybe recursively through the final match contract.

A more complicated version can use HDS so that players initially commit to an extended public key which is used to generate indexed public and private key pairs for each level of the lottery. These public-private key pairs serve as commitment-secret pairs in a match. HDS allows generating deterministic non-hardened public keys from an extended public key. If there is a 1-to-1 mapping from a public key to its private key, this can serve as deterministic commitments and secrets that are unpredictable before the owner of the extended private key reveals the i-th child key. Using this scheme allows us to reduce necessary on-chain transactions for the tournament. As each player commits to an extended public key initially, the coin tosses can be negotiated off-chain without risking revealing the secret (next private key) of the next level. But the match contracts can be used as enforcement if off-chain negotiation for any reason does not work. 

\subsection{Keep array of all matches in master contract}
Miller and Bentov's design doesn't have an explicit way to get all the matches for a lottery. One would have to iterate through all the matches' left and right field, starting from the final match. This takes some time, and can make it hard for new players to get the state of the lottery just from the blockchain itself. One could of course store the matches in a database for the website, but it's neater to only use the blockchain as a database, and no other services other than a static website. I'm considering redesigning the contracts a little bit so that all match contracts are stored in an array in the master contract.

I found out doing this requires a lot of gas in one transaction, which means the lottery can't have more than about 256 players. It could possibly still work if we create the tournament tree dynamically as participants join, but that probably makes the implementation more complicated than it needs to be in our context.

\subsection{Two different types of match contracts}
Miller and Bentov's design has match contracts with different behaviour. One is the first level match and the other for internal matches. They are implemented in the same smart contract, but it would save some transaction costs to have them in different smart contracts, as we wouldn't need to declare as many fields.

\subsection{Delete stored variables when they are no longer used}
I think a transaction gets some refund on gas if stored values are deleted. We can for example delete the commitments of a match after the secrets are verified and stored.