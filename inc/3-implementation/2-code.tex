\section{Code}
\label{sec:code}

The only smart contracts used in the lottery are the master contract and the two types of match contracts â€“ first level match contracts and internal match contracts, all of which are implemented as Solidity programs. Solidity is a high level language that compiles to EVM bytecode. Deploying a smart contract on Ethereum is done by making a special deployment transaction that contains the contract's compiled bytecode. A deployed contract is identified by a unique address that is assigned when the deployment transaction is made.

Setting up the lottery is a multi-step process that must happen in a specific order. First, the master contract needs to be deployed, then the first level match contracts which are all initialized with the address of the master contract are deployed. Internal match contracts from the same level in the tournament tree can be deployed at the same time, but match contracts of each level need a reference to matches in the previous level, which means matches in each level must be deployed incrementally. In order to manage this process, we have made a script to automate it. The smart contracts and deployment scripts also have associated unit tests and a simulation suite.

The listings included here have been truncated somewhat and are not necessarily compilable code. See the Github repository~\footnote{\url{https://github.com/viktorfa/lottery-truffle}} and Appendix \ref{chap:listings} for full working code.

\subsection{Master contract}
\texttt{LotteryMaster} is the smart contract responsible for registering participants, taking deposits, and distributing the prize. It serves as a central hub in the lottery that all players must interact with. Whoever deploys this contract is the lottery organizer, and is the only account with the authority to initialize the lottery by setting the final match. 

The constructor of this contract takes the number of participants \texttt{N}, the price of participation \texttt{price}, and a start time \texttt{tStart}. It is only possible to make a deposit after the final match of the lottery is set with \texttt{setFinalMatch()}. The \texttt{finalMatch} field is a reference to a match contract which is the apex of the tournament tree of matches. This field cannot be set on deployment, as the matches in the tournament need a reference to a master contract, and the master contract needs a reference to a match contract. Due to this circular dependency, either all the matches of the first level or the single master contract need a two-step initialization. Since the gas usage of a single transaction is less than that of many, we choose to have the two-step initialization in the single master contract.


\lstinputlisting[language={Solidity}, caption={Lottery master contract}, label={lst:LotteryMaster.sol}]{listings/LotteryMaster.sol}

\subsection{Match contract}
A match contract implements a digital coin toss between two players. The digital coin toss determines a winner either by the value of the least significant bit of the result of an XOR operation on the two players' secrets, or by one of the players failing to perform the procedures in the contract by some predetermined time limit.
Due to slightly different behaviour between matches of the first level of the tournament and matches in internal nodes of the tournament, we split the code between two smart contracts who both inherit an interface from an abstract smart contract.

A match has two players referenced by address in the \texttt{alice} and \texttt{bob} fields. By a start time \texttt{tCommit}, the players can set a commitment of bits with the \texttt{commit()} method. Another time limit is set in \texttt{tReveal} which is when making commitments is no longer possible, but revealing the secret committed to is possible. This is done with the \texttt{reveal()} method which verifies that the secret is the preimage of the commitment, and stores the secret in storage. The final time limit is \texttt{tPlay}, after which players can no longer reveal secrets. By the final limit the outcome of the match is guaranteed to be determined. 

The \texttt{getWinner()} method performs the digital coin toss if both players have revealed their secrets. If either player has performed more steps than the other player, e.g. made a commitment while the other has not, the player who has done the most steps will win. If neither player has revealed their secrets, and no player has performed more steps than the other, then the winner of the match will be \texttt{alice} player by default.

A match has a way to determine which players are eligible to play in it. This is handled differently in \texttt{FirstLevelMatch} and \texttt{InternalMatch}. The former is initialized with an index and a reference to a \texttt{LotteryMaster} contract. Each player in the master contract is indexed so that each player is paired with another who is their opponent in a match of the first level. The latter is initialized with a reference to two matches, \texttt{left} and \texttt{right}, of the previous level in the tournament. These matches will return their winner in the \texttt{getWinner()} method, which the internal match uses to determine its players. 

\lstinputlisting[language={Solidity}, caption={Lottery first level match contract}, label={lst:FirstLevelMatch.sol}]{listings/FirstLevelMatch.sol}
\lstinputlisting[language={Solidity}, caption={Lottery internal match contract}, label={lst:InternalMatch.sol}]{listings/InternalMatch.sol}

\subsection{Lottery setup code}
The lottery setup code is written in Javascript, an interpreted language that runs in all modern web browsers and in the NodeJS runtime environment. Since it's common to make web clients for smart contract applications and modern web apps are usually programmed in Javascript, that language is commonly used in the layer between user and the blockchain API. The Truffle framework is a library that provides a useful abstraction to smart contracts and the Ethereum RPC client, and includes tools for handling the development lifecycle of smart contracts. Web3js is a comprehensive library to interact with Ethereum and the EVM in Javascript.

In order to set up a valid lottery, the master contract and match contracts need to be initialized with correct parameters. In addition to testing and simulation, this is the main purpose of the lottery setup code. The lottery is set up by first deploying a master contract, then deploying, level for level starting from the first level, match contracts that constitute a valid tournament tree, and finally initializing the master contract with the final match of the tournament tree. The setup code finds the correct parameters for time limits, indices of first level matches, and left and right addresses for internal matches. 

The simulation code consists of two test suites. The first does the routine a lottery organizer needs to do in order to set up a lottery, which is creating and deploying the master contract and all match contracts. The second does all of what the first does in addition to simulating the lottery being played. In the second suite, players join by making deposits and then play each level of the tournament until one player is left as winner and withdraws the prize.
The time elapsed and gas used is recorded for each simulation for analysis.

\begin{figure}[htbp]
  \centering
  \includesvg[width=\columnwidth]{figures/tournament_tree_contracts.svg}
  \caption{Contracts in a lottery of 8 players}
\end{figure}
